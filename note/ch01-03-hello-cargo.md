# hello-cargo

---

```
$ cargo new hello_cargo --bin
$ cd hello_cargo
```

첫번째 커맨드는 hello_cargo라고 불리우는 새로운 실행 가능한 바이너리를 생성합니다. **cargo new에게 넘겨지는 --bin 인자가 라이브러리가 아닌 실행 가능한 애플리케이션으로 만들어줍니다** (흔히들 그냥 바이너리 (binary) 라고 부릅니다). 우리의 프로젝트는 hello_cargo 라고 이름지었고, Cargo는 동일한 이름의 디렉토리에 이 프로젝트의 파일들을 생성합니다.

- => 이미 같은 이름의 디렉토리가 존재할 경우 `already exists` 발생함.

hello_cargo 디렉토리로 가서 파일 리스트를 보세요. 여러분은 Cargo가 우리를 위해 두 개의 파일과 하나의 디렉토리를 생성한 것을 볼 수 있을 것입니다: Cargo.toml 파일 및 안에 main.rs 파일을 담고 있는 src 디렉토리가 그것입니다. 안에는 또한 .gitignore과 함께 새로운 Git 저장소도 초기화되어 있습니다.

---

Cargo는 여러분의 소스 파일들이 src 디렉토리 안에 있을 것으로 예상합니다. 최상위 프로젝트 디렉토리는 그저 README 파일들, 라이센스 정보, 환경 파일들, 그리고 여러분의 코드와는 관련이 없는 다른 것들 뿐입니다.

- => Cargo 를 사용하지 않고 프로젝트를 시작했다가 옮기고 싶으면 프로젝트 코드를 src 디렉토리로 옮기고 적합한 Cargo.toml 파일을 생성하면 됨.

---

- 빌드

  - `hello_cargo` 디렉토리에서

  ```
  cargo build
  ```

- 이 커맨드는 여러분의 현재 디렉토리 대신 target/debug/hello_cargo에 (혹은 Windows에서는 target\debug\hello_cargo.exe에) 실행 파일을 생성합니다. 여러분은 아래 커맨드를 통해 이 실행 파일을 실행할 수 있습니다:

- 처음으로 cargo build를 실행하는 것은 또한 Cargo가 최상위 디렉토리에 Cargo.lock 이라는 새로운 파일을 생성하도록 합니다.

- `cargo run`를 사용하여 한번의 커맨드로 코드를 컴파일한 다음 결과 실행파일을 실행할 수 있습니다:

- => 이 때의 실행에서는 컴파일 중이라는 출력을 볼 수 없는데, 그건 Cargo 가 파일들이 변경된 적 없음을 알아내고 해당 바이너리를 그냥 실행했기 때문임. 코드를 수정했었다면 Cargo 는 그 프로젝트를 실행하기 전에 다시 빌드할 것이고, 컴파일 중이라는 출력을 볼 수 있을 것.

- `cargo check`
  Cargo는 또한 cargo check라고 하는 커맨드를 제공합니다. 이 커맨드는 여러분의 코드가 컴파일되는지를 빠르게 확인해주지만 실행파일을 생성하지는 않습니다:

---

### 요약

- 우리는 cargo build나 cargo check를 사용하여 프로젝트를 빌드할 수 있습니다.
- 우리는 cargo run를 사용하여 단숨에 프로젝트를 빌드하고 실행할 수 있습니다.
- 우리 코드가 있는 동일한 디렉토리에 빌드의 결과물이 저장되는 대신, Cargo는 이를 target/debug 디렉토리에 저장합니다.

---

릴리즈 빌드

- 여러분의 프로젝트가 마침내 배포(릴리즈)를 위한 준비가 되었다면, cargo build --release를 사용하여 **최적화와 함께 이를 컴파일**할 수 있습니다.

- 이 커맨드는 target/debug 대신 target/release에 실행파일을 생성할 것

- 최적화는 여러분의 러스트 코드를 더 빠르게 만들어주지만, 최적화를 켜는 것은 여러분의 프로그램을 컴파일하는데 드는 시간을 길게 할 것입니다: 이것이 바로 두 개의 서로 다른 프로파일이 있는 이유입니다: 하나는 여러분이 빠르게 그리고 자주 다시 빌드하기를 원하는 개발용, 그리고 다른 하나는 반복적으로 다시 빌드를 할 필요 없고 가능한 빠르게 실행되어 여러분이 사용자들에게 제공할 최종 프로그램을 빌드하기 위한 용도입니다.
