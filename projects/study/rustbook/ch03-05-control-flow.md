제어문

### if 표현식

다른 언어의 if 문과 비슷하다.

그런데 조건문이 `bool` 이 되어야 함.

```rs
let number = 3;

if number {
    println!("number exist");
}
```

는 안됨.

```rs
if number < 5 {
    println!("number exist ")
}
```

와 같이 `bool` 로 표현해야 함.

"Rust는 boolean 타입이 아닌 것을 boolean 타입으로 자동 변환하지 않습니다."

else if 를 사용한 다중 조건문에서는 첫 번째로 조건이 참이 되는 불록만 찾아 실행하고, 한번 찾게 되면 나머지는 검사하지 않음.

너무 많은 `else if` 는 코드를 이해하기 어렵게 하므로, 둘 이상일 경우 코드를 리팩토링할 수 있음.
이럴 경우 `match` 분기 생성자를 사용 할 수 있음.

#### let구문에서 if 사용하기

`if` 가 표현식이기 때문에, 이를 `let` 구문의 우측에서 사용할 수 있음.

```rs
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!("The value of number is: {}", number);
```

변수 number에는 if식에서 산출된 값이 bound되게 됩니다.
이때 `if` 식에 속한 각 갈래의 결과는 반드시 같은 타입이여야 합니다.
예륻 들어 if 에서는 `i32` 를 반환하고, else 에서는 `$str` 을 반환하면 에러 발생.
`if`와 `else` 갈래의 값 타입이 호환되지 않고, Rust 는 정확히 프로그램의 어느 지점에 문제가 있는지 보여줌.
이런 경우가 성립하지 않는 이유는 변수가 가질 수 있는 타입이 오직 하나이기 때문입니다.
Rust는 컴파일 시에 number 변수의 타입이 뭔지 확실히! 정의해야 합니다. 그래야 number가 사용되는 모든 곳에서 유효한지 검증할 수 있으니까요. Rust는 number의 타입을 실행 시에 정의되도록 할 수 없습니다. 컴파일러가 모든 변수의 다양한 타입을 추적해서 알아내야 한다면 컴파일러는 보다 복잡해지고 보증할 수 있는 것은 적어지게 됩니다.

### 반복문과 반복

#### loop와 함께 코드의 반복 수행

loop keyword는 Rust에게 그만두라고 명시하여 알려주기 전까지 코드 블럭을 반복 수행합니다.
`break` 키워드를 위치키셔 프로그램이 언제 루프를 멈춰야 하는지 알려줄 수 있다.

조건 없이 무한 반복. break 로 중지.

#### while와 함께하는 조건부 반복

반복에 조건.
조건이 true인 동안 코드가 실행되고; 그렇지 않으면 루프에서 벗어납니다.

#### for와 함께하는 콜렉션 반복하기

배열과 같은 콜렉션의 각 요소에 걸쳐 반복 수행하고 싶을 때.

`while` 로도 할 수 있음.
그러나 이런 방식은 에러가 발생하기 쉽습니다; 우리가 정확한 길이의 색인을 사용하지 못하면 프로그램은 패닉을 발생합니다. 또한 느린데, 이유는 컴파일러가 실행 간에 반복문을 통해 반복될 때마다 요소에 대한 조건 검사를 수행하는 런타임 코드를 추가하기 때문입니다.

보다 효율적인 대안으로, 우리는 for 반복문을 사용하여 콜렉션의 각 요소에 대한 코드를 수행할 수 있습니다.

`for` 문을 사용함으로써 코드의 안전성을 높이고 배열의 끝을 넘어가거나 충분한 길이를 지정하지 못해 일부 아이템이 누락되어 발생할 수있는 버그의 가능성을 제거했습니다.

- Range
  Range는 한 숫자에서 다른 숫자 전까지 모든 숫자를 차례로 생성합니다.

```rs
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}

// 3!
// 2!
// 1!
// LIFTOFF!!!
```
